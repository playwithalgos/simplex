<!DOCTYPE html>
<meta charset="utf-8">

<body>
    Please write a linear program in canonical form:<br />
    <textarea oninput="compute()" id="input" rows="10" cols="40"></textarea>
    <div id="error"></div>
    <textarea id="output" readonly rows="50" cols="80"></textarea>

    <style>
        * {
            vertical-align: top;
            background-color: black;
            color: white;
        }

        #error {
            color: red;
        }

        #output {
            border: 0px;
        }

        textarea {
            color: greenyellow;
        }

        body {
            background-color: black;
        }
    </style>

    <script>

        /**
         * @description represents a Tableau in the simplex algorithm
         **/
        class Tableau {

            /**
             * v is the current value of the objective
             * c are the coefficients on the objective (as a JS object dictionnary var |-> value)
             * A the matrix (as a JS object of JS objects)
             * b the column vector (as a JS object)
             **/
            constructor(v, c, A, b) {
                this.v = v;
                this.c = c;
                this.A = A;
                this.b = b;

                const varsN = new Set([...Object.keys(c)]);

                for (const vB in A)
                    for (const vN in A[vB])
                        varsN.add(vN);

                const varsB = new Set([...Object.keys(A)]);

                for (const vB in A)
                    for (const vN of varsN) {
                        if (A[vB][vN] == undefined)
                            A[vB][vN] = 0;
                    }

                for (const vN of varsN) if (c[vN] == undefined) c[vN] = 0;

                this.varsB = varsB;
                this.varsN = varsN;
            }

            toString() {
                let s = "max " + ((this.v == 0) ? "" : (this.v + " + ")) + mapToStr(this.c);
                for (let v in this.b) {
                    s += "\n" + v + " = " + this.b[v] + " + " + mapToStr(this.A[v]);
                }
                s = s.replaceAll(" + -", " - ");
                s += "\n\n" + "variables in the base: " + [...T.varsB] + "\n" + "variables outside the base: " + [...T.varsN] + "\n\n    ---------------    \n";
                return s;
            }
        }

        /**
         * @parameter c an object for instance c = {x:1, y:-3, z:2} 
         * @returns a string representing the coefficients c
         * @example returns x + -3y + 2z if c = {x:1, y:-3, z:2} 
         * **/
        function mapToStr(c) {
            const A = [];
            for (let v in c) if (c[v] != 0) {
                A.push((
                    (c[v] == 1) ? "" : (c[v] == -1) ? "-" : c[v]) + v);
            }
            return A.join(" + ");
        }

        /**
         * @parameter line is a string, e.g. x - 3y + 2z
         * @returns a object {x:1, y:-3, z:2} 
         **/
        function lineToMap(line) {
            const lineCorrected = line.replaceAll("-", "+-");
            const termsStr = lineCorrected.split("+");
            const c = {};

            /**
             * @parameter a string for instance "2x"
             * @returns an array [coeff, variableName], e.g. [2, "x"]
             **/
            function splitTerm(termStr) {
                termStr = termStr.trim();

                let i;
                for (i = 0; i < termStr.length; i++)
                    if (["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "-", "+"].indexOf(termStr[i]) < 0)
                        break;

                let numberStr = termStr.substr(0, i);
                if (numberStr == "")
                    numberStr = "1";
                if (numberStr == "-")
                    numberStr = "-1";

                const coeff = parseFloatStrong(numberStr);
                if (coeff == undefined)
                    throw "the coefficient " + numberStr + " is not correct";
                const variablePart = termStr.substr(i).trimLeft();

                const variableName = (variablePart.startsWith("*")) ? variablePart.substr(1).trimLeft() : variablePart;


                if (variableName.indexOf(" ") >= 0)
                    throw "there are misplaced spaces in the term " + termStr;

                if (variableName == "")
                    throw "a variable name is missing";

                return [coeff, variableName];

            }

            for (const termStr of termsStr)
                if (termStr.trim() != "") {
                    const [val, varName] = splitTerm(termStr);
                    c[varName] = val;
                }
            return c;
        }

        /**
         * @paramter a string representing a tableau for instance "max 2x \n x + y <= 5 \n x <= 6"
         * @returns The corresponding Tableau object
         **/
        function strToTableau(strCanonicalForm) {
            const lines = strCanonicalForm.split("\n");
            const objStr = lines.shift().trim();
            if (!objStr.toLowerCase().startsWith("max "))
                throw "error: the first line should start with 'max' followed by the objective function";
            const obj = lineToMap(objStr.substr(4));

            const A = {};
            const b = {};
            let i = 1;
            for (const line of lines) if (line.trim() != "") {
                const D = line.split("<=");
                if (D.length != 2)
                    throw "Each constraint should be of the form 'linear function <= value'";

                const coeffs = lineToMap(D[0]);

                for (const v in coeffs)
                    coeffs[v] = - coeffs[v];

                const bc = parseFloatStrong(D[1].trim());
                if (bc == undefined)
                    throw `The value in 'linear function <= value' should be a number. Sorry but ${D[1]} is not a number`;
                A["z" + i] = coeffs;
                b["z" + i] = bc;
                i++;
            }

            return new Tableau(0, obj, A, b);
        }



        function parseFloatStrong(str) {
            const re = new RegExp(/^[+-]?\d+(\.\d+)?$/);
            if (str.search(re) == -1)
                return undefined;
            const bc = parseFloat(str);
            return bc;
        }

        let T;

        function init() {
            output.value = "";
            const initialTableau = strToTableau(input.value);
            T = initialTableau;
            output.value = initialTableau.toString();
        }


        function step() {
            const { j, i } = biggestCoeffRule(T);//blandRule(T);
            T = applyPivot(T, j, i);
            output.value = output.value + "\n\n" + j + " is entering in the base \n" + i + " is leaving the base\n\n" + T.toString();
        }


        function compute() {
            noError();
            try {
                init();
            }
            catch (e) {
                showError(e);
                return;
            }
            try {
                for (let i = 0; i < 100; i++)
                    step();
            }
            catch (e) {
                output.value = output.value + "\n\n" + e;
            }
        }

        /**
         * @parameter a Tableau object
         * @returns an object {i: variableNameI, j: variableNameJ} 
         * where variableNameI and variableNameJ are the variables used to perform the pivot 
         **/
        function blandRule(T) {
            const getJ = () => {
                for (let v of Object.keys(T.c).sort()) {
                    if (T.c[v] > 0)
                        return v;
                }
                return undefined;
            }

            const j = getJ();
            if (j == undefined)
                throw "We found the max!";

            const getI = () => {
                let min = Infinity;
                let vI = undefined
                for (let i in T.A)
                    if (T.A[i][j] < 0 && -T.b[i] / T.A[i][j] < min) {
                        vI = i;
                        min = -T.b[i] / T.A[i][j];
                    }
                return vI;
            }

            const i = getI();

            if (i == undefined)
                throw "unbounded because of variable " + j;

            return { i, j };
        }


        /**
         * same typing than Bland rule
         **/
        function biggestCoeffRule(T) {
            const getJ = () => {
                let j = undefined;
                let max = 0;
                for (let v in T.c)
                    if (T.c[v] > max) {
                        j = v;
                        max = T.c[v];
                    }

                return j;
            }

            const j = getJ();
            if (j == undefined)
                throw "We found the max!";

            const getI = () => {
                let min = Infinity;
                let vI = undefined
                for (let i in T.A)
                    if (T.A[i][j] < 0 && -T.b[i] / T.A[i][j] < min) {
                        vI = i;
                        min = -T.b[i] / T.A[i][j];
                    }
                return vI;
            }

            const i = getI();

            if (i == undefined)
                throw "unbounded because of variable " + j;

            return { i, j };
        }


        /**
         * @parameter T a tableau
         * @parameter j0
         * @parameter i0
         * @returns the tableau obtained from T by applying the pivot according to i0 and j0
         **/
        function applyPivot(T, j0, i0) {

            const v = T.v - T.b[i0] * T.c[j0] / T.A[i0][j0];
            const c = {};

            for (const j of T.varsN) if (j != j0)
                c[j] = T.c[j] - T.c[j0] * T.A[i0][j] / T.A[i0][j0];

            c[i0] = T.c[j0] / T.A[i0][j0];
            const b = {};

            for (const i of T.varsB) if (i != i0)
                b[i] = T.b[i] - T.A[i][j0] * T.b[i0] / T.A[i0][j0];

            b[j0] = -T.b[i0] / T.A[i0][j0];

            const A = {};

            for (const i of T.varsB) if (i != i0) {
                A[i] = {};
                for (const j in T.c) if (j != j0)
                    A[i][j] = T.A[i][j] - T.A[i][j0] * T.A[i0][j] / T.A[i0][j0];

                A[i][i0] = T.A[i][j0] / T.A[i0][j0];
            }

            A[j0] = {};
            A[j0][i0] = 1 / T.A[i0][j0];

            for (const j of T.varsN) if (j != j0)
                A[j0][j] = -T.A[i0][j] / T.A[i0][j0];

            return new Tableau(v, c, A, b);
        }

        function showError(msg) { document.getElementById("error").innerHTML = msg; }
        function noError() { document.getElementById("error").innerHTML = ""; }

    </script>
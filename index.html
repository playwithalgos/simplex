<!DOCTYPE html>
<meta charset="utf-8">

<body>
    <textarea id="input" rows="10" cols="40"></textarea>
    <button onclick="compute()">Compute</button>
    <textarea id="output" rows="50" cols="80"></textarea>

    <style>
        * {
            vertical-align: top;
        }
    </style>

    <script>
        class Tableau {
            constructor(v, c, A, b) {
                this.v = v;
                this.c = c;
                this.A = A;
                this.b = b;

                const varsN = new Set([...Object.keys(c)]);

                for (const vB in A)
                    for (const vN in A[vB])
                        varsN.add(vN);

                const varsB = new Set([...Object.keys(A)]);

                for (const vB in A)
                    for (const vN of varsN) {
                        if (A[vB][vN] == undefined)
                            A[vB][vN] = 0;
                    }

                for (const vN of varsN) if (c[vN] == undefined) c[vN] = 0;

                this.varsB = varsB;
                this.varsN = varsN;
            }

            toString() {
                let s = "max " + ((this.v == 0) ? "" : (this.v + " + ")) + mapToStr(this.c);
                for (let v in this.b) {
                    s += "\n" + v + " = " + this.b[v] + " + " + mapToStr(this.A[v]);
                }
                s = s.replaceAll(" + -", " - ");
                s += "\n\n" + "variables in the base: " + [...T.varsB] + "\n" + "variables outside the base: " + [...T.varsN] + "\n\n    ---------------    \n";
                return s;
            }
        }

        function mapToStr(c) {
            const A = [];
            for (let v in c) if (c[v] != 0) {
                A.push((
                    (c[v] == 1) ? "" : (c[v] == -1) ? "-" : c[v]) + v);
            }
            return A.join(" + ");
        }

        function lineToMap(line) {
            const terms = line.split("+");
            const c = {};

            function splitTerm(term) {
                term = term.trim();
                let i;
                for (i = 0; i < term.length; i++) {
                    if (["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "-", "+"].indexOf(term[i]) < 0) {
                        break;
                    }
                }
                let numberStr = term.substr(0, i);
                if (numberStr == "")
                    numberStr = "1";
                return [parseFloat(numberStr), term.substr(i).trim()];

            }


            for (const term of terms) {
                const [val, varName] = splitTerm(term);
                c[varName] = val;
            }
            return c;
        }

        function strToTableau(strCanonicalForm) {
            const lines = strCanonicalForm.split("\n");
            const objStr = lines.shift();
            const obj = lineToMap(objStr.substr(4));

            const A = {};
            const b = {};
            let i = 1;
            for (const line of lines) if (line.trim() != "") {
                const D = line.split("<=");
                const coeffs = lineToMap(D[0]);

                for (const v in coeffs)
                    coeffs[v] = - coeffs[v];

                const bc = parseFloat(D[1]);
                A["e" + i] = coeffs;
                b["e" + i] = bc;
                i++;
            }

            return new Tableau(0, obj, A, b);
        }


        let T;

        function init() {
            const initialTableau = strToTableau(input.value);
            T = initialTableau;
            output.value = initialTableau.toString();
        }

        init();

        function step() {
            const { j, i } = blandRule(T);
            T = applyPivot(T, j, i);
            output.value = output.value + "\n\n" + j + " is entering in the base \n" + i + " is leaving the base\n\n" + T.toString();
        }


        function compute() {
            init();
            for (let i = 0; i < 100; i++) {
                step();
            }
        }

        function blandRule(T) {
            const getJ = () => {
                for (let v in T.c) {
                    if (T.c[v] > 0)
                        return v;
                }
                return undefined;
            }

            const j = getJ();
            if (j == undefined)
                throw "max";

            const getI = () => {
                let min = Infinity;
                let vI = undefined
                for (let i in T.A)
                    if (T.A[i][j] < 0 && -T.b[i] / T.A[i][j] < min) {
                        vI = i;
                        min = -T.b[i] / T.A[i][j];
                    }
                return vI;
            }

            const i = getI();

            if (i == undefined)
                throw "unbounded with j = " + j;

            return { i, j };
        }



        function applyPivot(T, j0, i0) {

            const v = T.v - T.b[i0] * T.c[j0] / T.A[i0][j0];
            const c = {};

            for (const j of T.varsN) if (j != j0) {
                c[j] = T.c[j] - T.c[j0] * T.A[i0][j] / T.A[i0][j0];
            }
            c[i0] = T.c[j0] / T.A[i0][j0];
            const b = {};

            for (const i of T.varsB) if (i != i0) {
                b[i] = T.b[i] - T.A[i][j0] * T.b[i0] / T.A[i0][j0];
            }

            b[j0] = -T.b[i0] / T.A[i0][j0];

            const A = {};

            for (const i of T.varsB) if (i != i0) {
                A[i] = {};
                for (const j in T.c) if (j != j0) {
                    A[i][j] = T.A[i][j] - T.A[i][j0] * T.A[i0][j] / T.A[i0][j0];
                }
                A[i][i0] = T.A[i][j0] / T.A[i0][j0];
            }

            A[j0] = {};
            A[j0][i0] = 1 / T.A[i0][j0];

            for (const j of T.varsN) if (j != j0) {
                A[j0][j] = -T.A[i0][j] / T.A[i0][j0];
            }

            return new Tableau(v, c, A, b);
        }


    </script>
<!DOCTYPE html>
<meta charset="utf-8">

<body>
    Please write a linear program in canonical form:<br />
    <textarea oninput="compute()" id="input" rows="10" cols="40"></textarea>
    <input id="bland" type="checkbox" oninput="compute()"></input>
    <label for="bland">Bland's rule</label>
    <div id="error"></div>
    <div id="output"></div>

    <style>
        body {
            vertical-align: top;
            background-color: black;
            color: lightyellow;
        }

        #error {
            color: red;
        }

        #output {
            border: 0px;
        }

        textarea {
            background-color: black;
            color: greenyellow;
        }

        body {
            background-color: black;
        }

        .max {
            font-weight: bold;
            margin-right: 8px;
        }

        .nonbasicvariable {
            color: lightgray;
        }

        .basicvariable {
            color: lightskyblue;
        }

        .pivot {
            margin: 8px;
            padding-left: 16px;
        }

        .obj {
            background-color: darkgreen;
            padding: 2px;
        }

        .tableau {
            margin: 8px;
            padding: 8px;
            background-color: rgb(60, 60, 60);
            display: inline-block;
            border-radius: 8px;
        }
    </style>

    <script>
        const SLACKVARIABLEPREFIX = "ε";
        /**
         * @description represents a Tableau in the simplex algorithm
         **/
        class Tableau {

            /**
             * v is the current value of the objective
             * c are the coefficients on the objective (as a JS object dictionnary var |-> value)
             * A the matrix (as a JS object of JS objects)
             * b the column vector (as a JS object)
             **/
            constructor(v, c, A, b) {
                this.v = v;
                this.c = c;
                this.A = A;
                this.b = b;

                const varsN = new Set([...Object.keys(c)]);

                for (const vB in A)
                    for (const vN in A[vB])
                        varsN.add(vN);

                const varsB = new Set([...Object.keys(A)]);

                for (const vB in A)
                    for (const vN of varsN) {
                        if (A[vB][vN] == undefined)
                            A[vB][vN] = 0;
                    }

                for (const vN of varsN) if (c[vN] == undefined) c[vN] = 0;

                this.varsB = varsB;
                this.varsN = varsN;
            }

            toString() {
                let s = "max " + ((this.v == 0) ? "" : (numberToStr(this.v) + " + ")) + mapToStr(this.c);
                for (let v in this.b) {
                    s += "\n" + v + " = " + numberToStr(this.b[v]) + " + " + mapToStr(this.A[v]);
                }
                s = s.replaceAll(" + -", " - ");
                // s += "\n\n" + "variables in the base: " + [...T.varsB] + "\n" + "variables outside the base: " + [...T.varsN] + "\n\n    ---------------    \n";
                return s;
            }


            toHTML() {
                let s = "<div class='tableau'><span class='max'>max</span>" + "<span class='obj'>" + numberToStr(this.v) + "</span> + "
                    + mapToHTML(this.c) + "<br/>";
                for (let v in this.b) {
                    s += "\n" + `<span class="basicvariable">${v}</span>` + " = " + numberToStr(this.b[v]) + " + " + mapToHTML(this.A[v]) + "<br/>";
                }
                s = s.replaceAll(" + -", " - ");
                return s + "</div>"
            }

            get hasBasicSolution() {
                for (const v in this.b) {
                    if (this.b[v] < 0)
                        return false;
                }
                return true;

            }
        }



        function numberToStr(x) {
            return +parseFloat(x).toFixed(2);
        }

        /**
         * @parameter c an object for instance c = {x:1, y:-3, z:2} 
         * @returns a string representing the coefficients c
         * @example returns x + -3y + 2z if c = {x:1, y:-3, z:2} 
         * **/
        function mapToStr(c) {
            const A = [];
            for (let v in c) if (c[v] != 0) {
                A.push((
                    (c[v] == 1) ? "" : (c[v] == -1) ? "-" : numberToStr(c[v])) + v);
            }
            return A.join(" + ");
        }


        /**
         * @parameter c an object for instance c = {x:1, y:-3, z:2} 
         * @returns a string representing the coefficients c
         * @example returns x + -3y + 2z if c = {x:1, y:-3, z:2} 
         * **/
        function mapToHTML(c) {
            const A = [];
            for (let v in c) if (c[v] != 0) {
                A.push((
                    (c[v] == 1) ? "" : (c[v] == -1) ? "-" : numberToStr(c[v])) + `<span class="nonbasicvariable">${v}</span>`);
            }
            return A.join(" + ");
        }

        /**
         * @parameter line is a string, e.g. x - 3y + 2z
         * @returns a object {x:1, y:-3, z:2} 
         **/
        function lineToMap(line) {
            const lineCorrected1 = line.replaceAll("-", "+-");
            const lineCorrected = lineCorrected1.startsWith("+-") ? lineCorrected1.substr(1) : lineCorrected1;
            const termsStr = lineCorrected.split("+");
            const c = {};

            /**
             * @parameter a string for instance "2x"
             * @returns an array [coeff, variableName], e.g. [2, "x"]
             **/
            function splitTerm(termStr) {
                termStr = termStr.trim();

                let i;
                for (i = 0; i < termStr.length; i++)
                    if (["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "-", " ", "+"].indexOf(termStr[i]) < 0)
                        break;

                let numberStr = termStr.substr(0, i).trim();
                if (numberStr == "")
                    numberStr = "1";
                if (numberStr == "-")
                    numberStr = "-1";

                const coeff = parseFloatStrong(numberStr);
                if (coeff == undefined)
                    throw "the coefficient " + numberStr + " is not correct";
                const variablePart = termStr.substr(i).trimLeft();

                const variableName = (variablePart.startsWith("*")) ? variablePart.substr(1).trimLeft() : variablePart;


                if (variableName.indexOf(" ") >= 0)
                    throw "there are misplaced spaces in the term " + termStr;

                if (variableName == "")
                    throw "a variable name is missing";

                if (variableName.search(/^[a-zA-Z]?[a-zA-Z0-9]*$/) < 0)
                    throw "Problem with " + variableName + ": a variable name should start with a letter and can be followed by letters and/or digits";

                return [coeff, variableName];

            }

            for (const termStr of termsStr)
                if (termStr.trim() != "") {
                    const [val, varName] = splitTerm(termStr);

                    if (c[varName] != undefined)
                        throw "variable " + varName + " appears several times";
                    c[varName] = val;
                }
                else
                    throw " a term like 2x, -3y or something is missing";

            return c;
        }

        /**
         * @paramter a string representing a tableau for instance "max 2x \n x + y <= 5 \n x <= 6"
         * @returns The corresponding Tableau object
         **/
        function strToTableau(strCanonicalForm) {
            const lines = strCanonicalForm.split("\n");
            const objStr = lines.shift().trim();
            if (!objStr.toLowerCase().startsWith("max "))
                throw "error: the first line should start with 'max' followed by the objective function";
            const obj = lineToMap(objStr.substr(4));

            const A = {};
            const b = {};
            let i = 1;
            for (const line of lines) if (line.trim() != "") {
                const D = line.split("<=");
                if (D.length != 2)
                    throw "Each constraint should be of the form 'linear function <= value'";

                const coeffs = lineToMap(D[0]);

                for (const v in coeffs)
                    coeffs[v] = - coeffs[v];

                const bc = parseFloatStrong(D[1].trim());
                if (bc == undefined)
                    throw `The value in 'linear function <= value' should be a number. Sorry but ${D[1]} is not a number`;
                A[SLACKVARIABLEPREFIX + i] = coeffs;
                b[SLACKVARIABLEPREFIX + i] = bc;
                i++;
            }

            return new Tableau(0, obj, A, b);
        }



        function parseFloatStrong(str) {
            str = str.trim();
            const re = new RegExp(/^[+-]?\s*\d+(\.\d+)?$/);
            if (str.search(re) == -1)
                return undefined;
            str = str.replaceAll(" ", "").trim();
            const bc = parseFloat(str);
            return bc;
        }

        let T;
        let html = "";
        function init() {
            html = "";
            const initialTableau = strToTableau(input.value);
            T = initialTableau;
            if (!T.hasBasicSolution) {
                throw "the initial tableau has no basic solution";
            }
            html = initialTableau.toHTML();
        }


        function step() {
            const pivotFunction = document.getElementById("bland").checked ? blandRule : biggestCoeffRule;
            const { j, i } = pivotFunction(T);
            T = applyPivot(T, j, i);
            //   output.value = output.value + "\n\n" + j + " is entering in the base \n" + i + " is leaving the base\n\n" + T.toString();
            html = html + `<div class="pivot"><span class="basicvariable">${j}</span> ← <span class="nonbasicvariable">${j}</span><br/>` +
                `<span class="basicvariable">${i}</span> → <span class="nonbasicvariable">${i}</span><br/></div>`
                + T.toHTML();
        }


        function compute() {
            noError();
            try {
                init();
            }
            catch (e) {
                showError(e);
                return;
            }
            try {
                for (let i = 0; i < 100; i++)
                    step();
                output.innerHTML = html;

            }
            catch (e) {
                html = html + "\n\n" + e;
                output.innerHTML = html;
            }
        }



        function chooseEnteringVariableBiggestCoeff(T) {
            let j = undefined;
            let max = 0;
            for (let v in T.c)
                if (T.c[v] > max) {
                    j = v;
                    max = T.c[v];
                }

            return j;
        }


        function chooseEnteringVariableSmallestSubscript(T) {
            for (let v of Object.keys(T.c).sort()) {
                if (T.c[v] > 0)
                    return v;
            }
            return undefined;
        }

        function chooseLeavingVariableSmallestSubscript(T, j) {
            let min = Infinity;
            let vI = undefined
            for (let i in T.A)
                if (T.A[i][j] < 0 && -T.b[i] / T.A[i][j] < min) {
                    vI = i;
                    min = -T.b[i] / T.A[i][j];
                }
            return vI;
        }


        /**
         * @parameter a Tableau object
         * @returns an object {i: variableNameI, j: variableNameJ} 
         * where variableNameI and variableNameJ are the variables used to perform the pivot 
         **/
        function blandRule(T) {
            const j = chooseEnteringVariableSmallestSubscript(T);
            if (j == undefined)
                throw "We found the max!";


            const i = chooseLeavingVariableSmallestSubscript(T, j);

            if (i == undefined)
                throw "unbounded because of variable " + j;

            return { i, j };
        }





        /**
         * same typing than Bland rule
         **/
        function biggestCoeffRule(T) {
            const j = chooseEnteringVariableBiggestCoeff(T);
            if (j == undefined)
                throw "We found the max!";

            const i = chooseLeavingVariableSmallestSubscript(T, j);

            if (i == undefined)
                throw "unbounded because of variable " + j;

            return { i, j };
        }


        /**
         * @parameter T a tableau
         * @parameter j0
         * @parameter i0
         * @returns the tableau obtained from T by applying the pivot according to i0 and j0
         **/
        function applyPivot(T, j0, i0) {

            const v = T.v - T.b[i0] * T.c[j0] / T.A[i0][j0];
            const c = {};

            for (const j of T.varsN) if (j != j0)
                c[j] = T.c[j] - T.c[j0] * T.A[i0][j] / T.A[i0][j0];

            c[i0] = T.c[j0] / T.A[i0][j0];
            const b = {};

            for (const i of T.varsB) if (i != i0)
                b[i] = T.b[i] - T.A[i][j0] * T.b[i0] / T.A[i0][j0];

            b[j0] = -T.b[i0] / T.A[i0][j0];

            const A = {};

            for (const i of T.varsB) if (i != i0) {
                A[i] = {};
                for (const j in T.c) if (j != j0)
                    A[i][j] = T.A[i][j] - T.A[i][j0] * T.A[i0][j] / T.A[i0][j0];

                A[i][i0] = T.A[i][j0] / T.A[i0][j0];
            }

            A[j0] = {};
            A[j0][i0] = 1 / T.A[i0][j0];

            for (const j of T.varsN) if (j != j0)
                A[j0][j] = -T.A[i0][j] / T.A[i0][j0];

            return new Tableau(v, c, A, b);
        }

        function showError(msg) { document.getElementById("error").innerHTML = msg; }
        function noError() { document.getElementById("error").innerHTML = ""; }

    </script>